React 2021 Up and Running Notes
---------------------------------------------------------------------------------------------------------
01 SETTING UP
---------------------------------------------------------------------------------------------------------


public\index.html -->       src\index.js        -->             src\App.js
(holds the root)      (renders <App /> in root)     (App component/Top of component tree)


CREATE NEW REACT PROJECT --> npx create-react-app app-name


BUILD PRODUCTION VERSION --> npm run BUILD
    (this will be an optimised version of the project)


START DEVELOPMENT SERVER --> npm start
    (when running dev version you can view the components in dev tools)


SERVE PRODUCTION VERSION FROM BUILD FOLDER --> npx serve -s build
    (requires the installation of the serve package)
    (can not view react component in dev tools)


---------------------------------------------------------------------------------------------------------
02 - WORKING WITH JSX
---------------------------------------------------------------------------------------------------------


In React we create modules/components that are each a function that returns a single object containing html. The basic way to do this would be to
use React.createElement() to manually create each html element. Instead, we can use JSX to write html like code that we be converted by BABEL using
React.createElement(). BABEL converts our JSX into an object that will contain html.


Since our JSX will mostly span multiple line we want to be sure to add parenthesis after our return to avoidJavaScript's automatic semi-colon injection (end so return nothing/exit early). Everthing inside the parenthesis of return() will be treated as if it is on the same line as the return statement. If we used parenthesis {} then we would be returning an object which we don't want to do, we want to feed JSX to BABEL.


Each component function can only return ONE JSX element. BABEL is expecting one to convert using React.createElement() and so there will be an error if it receives two. We can, however, have mulitple JSX elements nested inside a top level element that is being returned. The main thing is that there can only be ONE TOP LEVEL ELEMENT. This could be a <div>, a <main>, or a react fragment <></>.


JSX is JavaScript not HTML so when we add attributes to JSX elements we have to remember to do so in the JavaScript way. Instead of adding class="", we would add className="". The pattern is camelCase.


If we are using a simple string for an attribute we can pass it in with double quotes. If we want to pass in a variable we need to use parenthesis e.g. let appStyle = 'App'    className={appStyle}.


In JSX we can 'escape' to pure JavaScript using parenthesis e.g. { return 2 + 2 }. Sometimes an attribute may be expecting an object and so if we want to hard code it there with JavaScript we actually need double parenthesis {{}} e.g. style={{color: 'green'}}


---------------------------------------------------------------------------------------------------------
03 COMPONENTS AND PROPS
---------------------------------------------------------------------------------------------------------


React is fundamentally about building an interface. The way we do this is not by creating the whole thing in one big file but instead by making many small pieces of the interface which we can then insert into our top level component, <App />.


Before a class based approach was used but now the convention is to use functional components. Each component is it's own file that exports a function that returns JSX. Here's a bsic example:

    export default function App() {
        return (
            <div>
                ...
            </div>
    );
    }


The old class based approach made components like so:

    import React from 'react'

    export default class App extends React.Component{
        constructor(props){
            super(props)
        }

        render() {
            return (
                <div>
                    ...
                </div>
            )
        }
    }


Whether we want to use class or function components the important thing to know is that each component is it's own .js or .jsx file which another component (usually our top level App component) can import and use the html it returns (thanks to BABEL). So our top level component may end up looking something like this:

    import "./App.css";
    import Header from 'components/Header/Header';
    import Main from 'components/Main/Main';
    import Footer from 'components/Footer/Footer';

    function App() {
    return (
        <div className="App">
            <Header />
            <Main />
            <Footer />
        </div>
    );
    }

    export default App;


So we simply import the component and insert them like lego blocks to make use of the html their function returns. Notice the convention of putting all components in their own folder inside a parent component folder (in src) and also every component is capitalised. We can also have a css file in each component folder to style each component individually.


So the file structure would be:

    \src
        \components
            \Header
                Header.js
                header.css
            \Main
                Main.js
                main.css
            \Footer
                Footer.js
                footer.css
        App.js


PROPS

Props are properties that we can pass DOWN from one component to another but not up the tree e.g. we could pass a prop from App down to Header but we can't pass a prop from Header up to App.


The way we pass props to component is to include them like attributes in the higher level component e.g. 

    import Header from "./components/Header/Header";

    export default function App() {
    const name = "Acme";
        return (
            <div className="App">
            <Header companyName={name} />
            </div>
        );
    }



The prop could be called anything we want and we don't need to assign a variable first to pass into a prop like we have here.


So far we've passed the name variable as a prop to our Header component but we haven't made use of it in any way. To do that we go to our Header.js, include props as an argument of the function, then reference it as a piece of JavaScript in our JSX e.g.

    export default function Header(props) {
        return (
            <header className="masthead">
            <h1>{props.companyName}</h1>
            <Nav />
            </header>
        );
    }


We don't need to call the argument passed in props but it is the standard convention. If we had passed in as (bill) then we would access the prop we want as {bill.companyName}.


We can also use destructuring to make this cleaner, eliminating the need to use the props prefix e.g.

    export default function Header({ companyName }) {
        return (
            <header className="masthead">
            <h1>{companyName}</h1>
            <Nav />
            </header>
        );
    }

With destructuring the name passed into the argument must EXACTLY match the name we passed into the component in the parent.


We can pass as many props as we like down, for example lets also pass down a title to Header

    export default function App() {
        const name = "Acme";
        return (
            <div className="App">
            <Header companyName={name} title="hard coded" />
            </div>
        );
    }


Now say we don't want to use this in our Header but instead in our Nav, we simply pass it down another level where we use the Nav component in our Header component

    export default function Header(props) {
        let title = props.title;
            return (
                <header className="masthead">
                <h1>{props.companyName}</h1>
                <Nav title={title}/>
                </header>
            );
    }


Then we can make use of the prop.title, that was passed from App to Header then from Header to Nav, inside our Nav component

    import "./nav.css";

    export default function Nav(props) {
        return <nav>{props.title}</nav>;
    }

The prop didn't need to have the same name as it started with in App, we could have passed it down to Nav in the Header component with a different name (e.g. let ttl = props.title) but it helps to be consistent.

Props can be passed down the chain/tree of components from parent to child in this way, like a human chain passing buckets of water. For example we could pass the props Header has received down to <Nav />


You may be wondering 'what if we want to pass a property up the component tree?'. We will cover this later but essentially we can define a property and a function that sets it in the top component (say App for example) and we can then pass the setter function down as a prop. The child component can then use the function to alter the property living in the top component. This will become more clear when we start working with the useState() Hook.


As a final note we can also move our App.js, app.cs, and App.test.js into an App file in our components folder to be consistent. Just remember to change the import locations to reflect this, including the App import in src\index.js (e.g. import App from "./components/App/App";)


---------------------------------------------------------------------------------------------------------
04 COMPONENTS FROM DATA
---------------------------------------------------------------------------------------------------------


We've seen creating components declaratively/manually but one of the most common things we'll want to do is take a list or array of data and create JSX/HTML/components from that list programatically. Typically, this will involve mapping over the data to return the data inside JSX elements.

For this example lets say we have some data inside our Nav component that we want to display inside of a Link component. To do this we want to map over the data and return a Link component but we also want to pass the data a prop into the Link component. This allows us to include the data in our Link component. It might seems a little chicken and egg but we can flesh out the JSX of the Link component knowing that Nav will pass the data too it.

    export default function Nav() {
        const links = [
            { title: "Films", url: "https://swapi.dev/api/films/" },
            { title: "People", url: "https://swapi.dev/api/people/" },
            { title: "Planets", url: "https://swapi.dev/api/planets/" },
        ];

        return (
            <nav>
            {links.map((item, idx) => (
                <Link key={idx} data={item}/>
            ))}
            </nav>
        );
    }

And then one step down the tree...

    export default function Link({ data }) {
        return <div>{data.title}</div>;
    }

As you can see I've chosen to destructure the props here. If I had simply passed props as an argument I could have accessed the title with props.data.title. Alternatively, if I know I only want the title and nothing else I could instead have only passed this is during the map e.g. title={item.title}, then inside of Link I can simply destructure ({ title }) and use it as { title }. However, this would mean if we also wanted the url we'd have to pass that as a seperate prop.

Notice that when we map we can also chose to get access to the index. The reason I did this here is because I wanted to use it as each returned element's key property. But what is a key property? React doesn't have a way of knowing which element being returned by map is which. When React need to rerender it only wants to rerender what's absolutely necessary. Typically if the mapped out elements are in the same order and haven't changed then React can see this and will not rerender them but if we were to put a new element at the beginning or in the middle React will not be able to recognise any elements that are now in a different order and so will have to rerender them, wasting resources. By including a key attribute we help React recognise returned elements and avoid rerendering them unnecessarily; React can reconise previously rendered elements even when in a different order. This might not seem like a big deal but if you had an array of 10,000 objects everytime you inserted a new item React would have to rerender every item that has changed position in the array (so if you unshift an item in, all of them). For this reason we typically don't want to use index since it changes as the element moves in the array and would not avoid this rerendering. Instead we can use a 3rd party library like UUID to get unique keys for each element.


To summarise, when we want to generate components programatically we need to map over the collection of data we want to use, return the component while passing the props we need into it, and finally give each returned item a unique key to help React be efficient with its rendering.


---------------------------------------------------------------------------------------------------------
05 Adding Events
---------------------------------------------------------------------------------------------------------


We're used to adding event logic by querySelecting an html element in JavaScript and adding an event listener to it e.g. menuButton.addEventListener('click', () => {...}) etc.

Synthetic Events Reference --> https://reactjs.org/docs/events.html

With React we use 'Synthetic Events'. These are React events that are returned instead of the browser's native events, so instead of the mouseout event we work with onMouseLeave in React. The Synthetic Events have all the same properties as the native events (e.g. preventDefault(), bubbles, type, etc.).

Instead of adding event listeners to elements, in React we assign a function to an event by assigning it like an attribute to JSX elements. Instead of .addEventListener('click', ...) we instead do something like <div onClick={handleClick}></div> where handleClick() is a function we have already defined (usually inside the function component, before the return statement).

It's important to know that these attribute like Syntetic Events have to go on JSX ELEMENTS, NOT COMPONENTS. This is becuase JSX elements are essentially HTML whereas Components are essentially JavaScript objects and can't have event handlers attached to them. So, in short, this wouldn't work --> <Link onClick={handleClick} /> but this would <div onClick={handleClick}><Link /></div>.

Put another way, Synthetic Events have to be attached to things that will render to HTML, namely, JSX elements.

We can enter the function like this onClick={doathing} or like this onClick={() => doathing()} or if we want the event onClick={(ev) => doathing(ev)}. 

Here's an example of a simple form using synthetic events

    export default function SearchBar(props) {
        function submitted(ev) {
            ev.preventDefault();
            console.log("submitted");
        }

         function focused(ev) {
            console.log("onFocus");
        }

        function changed(ev) {
            console.log("onInput", ev.target.value);
        }

        function clicked(ev) {
            console.log("clicked");
        }

    return (
        <section className="searchBar">
        <form onSubmit={submitted}>
            <input
            className="searchText"
            type="text"
            name="keyword"
            placeholder="keyword"
            onFocus={focused}
            onInput={changed}
            />
            <button
            className="searchBtn"
            type="submit"
            name="searchBtn"
            onClick={clicked}
            >
            Search
            </button>
        </form>
        </section>
    );
    }

As you can see we have multiple functions defined at the top to handle multiple events. We then call those functions for the relevant events in the revelevant elements e.g. onClick for the button, onChange for the input etc.

These will end up being utalised as a component but the synthetic events are on JSX elements.


---------------------------------------------------------------------------------------------------------
06 Hooks
---------------------------------------------------------------------------------------------------------


Hooks are premade methods we can import from the React Library that can give our functional components super powers! They allow our functional components to 'hook into' state and lifecycle methods.


When we used to use class based components we had the property this.state that we could use to store and update state in our components but we do not have this with functional components. Instead, we can use the useState Hook.

To use the useState hook we first need to import it into our component from the react library

    import {useState} from 'react';

Now we call the useState function in our component. When we call this function it will return 2 objects, a property to store some state and a method to set the value of that property so we call the function and assign it to variables like so:

    const [count, setCount] = useState(0)

Notice that we can pass in the initial value we want the state to have as an argument, in this case 0. We can also leave this blank.

Something to bare in mind that this does not represent a universal holder of state for our component like this.state did, instead you would make multiple states for multiple purposes e.g.

    const [count, setCount] = useState(0)
    const [name, setName] = useState('tim')
    const [customer, setCustomer] = useState({id: 0, discountcode: '12', email: 'bill@ben.com'})

Notice you can use useState with objects and arrays, not just simple data types.

We can then use these state values in our JSX just like if we created a variable e.g. <h1>{name}</h1>

If we want to change the value of a state dynamically we can do so using it's setX method e.g. count can be changed with setCount.

Here's an example of changing a greeting state value using a button

    <button
        onClick={() => {
            setGreeting("felicitations");
        }}
        >
        change greeting
    </button>

We must always use this setter method to alter state and never attempt to alter it directly 
e.g. greeting = 'new greeting'. This is becuase the setter method doesn't just change the state's value, it 'watches' for a change in that state and tells React to rerender when its state changes. When we attempt to modify the state directly React doesn't know it's changed.

Here's an example of setting state on a form submit. Notice that we can access the relevant field inside the form using its name property (in this case keyword). Since this method is being called on submit the target is the form.

    const [myprop, setMyProp] = useState("default value");

    function submitted(ev) {
        ev.preventDefault();
        console.log("submitted");
        setMyProp(ev.target["keyword"].value);
    }

So this would change the value of the myprop state to be whether is in the keyword input field when the user submits the form (calling this function).

If a state (say term in this case) is an empty string then it will still be rendered if included like this <p>{term}</p>. We won't see anything on the page but if we don't want the paragraph to be rendered at all we can use a ternary to show it conditionally. This works because an empty string is falsey.

    {term ? <p>You searched for {term}</p> : ""}

So if term is not an empty string (truthy) it will render the paragraph and if term is empty (falsy) it will return an empty string. This empty string is not in a paragraph element like the empty string from term was before so it will not be rendered, it effectively returns nothing.

Something to know is a ternary returns an expression conditionally and does not control the flow of your program, for that stick to if statements.

If we only want to use state inside the component we declare it in then there's no problem with that. However, just like props, state cannot be passed up the tree, only down, and so we need to make sure we declare state high enough for all the components we want to have access to it. We can then pass down the setter function as a prop and child components can alter state of higher/parent components.

Let's suppose we want <SearchBar /> to get our most recent term and we want <SearchHistory /> to get all of the terms that have been submitted. We can achieve this by creating a state in <App /> that stores an array of terms searched for. Then we can pass the entire array (as a prop, like an attribute) to the <SearchHistory /> component and the latest entry to the <SearchBar /> component. We also need to pass the setter method down to <SearchBar /> so that it can add new terms to the array.

An important thing to notice with this - a child component can't pass state up to a parent BUT if the parent passes its setter method down to the child, the child can change the state in the parent using the parents setter method. It like a child having no money to buy something (state) but if a parent gives the child their credit card details (method to use/change money state of the parent) then the child can alter the parents money state, even though the child still doesn't have any money (state) of their own.

No in <SearchHistory /> we can map through the array (remembering to give each a key) and return each term in the array as a list element

    export default function SearchHistory(props) {
        return (
            <ul>
            {props.terms.map((term) => (
                <li key={term}>{term}</li>
            ))}
            </ul>
        );
    }

Assuming we will add new terms to the beginning of our array we can pass the first item into <SearchBar /> from <App /> like so --> <SearchBar term={terms[0]} />. Then we access it with {props.term} inside <SearchBar />.

Now on to adding new terms from a child component. We can't directly pass the state setter down, that has to be triggered in the component in which it is defined/where the state is. Instead we can call the setter in our own function and pass THAT down. Since we want to put the new term at the beginning we can use the spread operator to set a new array as the terms state with the new term at the beginning

  function addTerm(term) {
    setTerms([term, ...terms]);
  }

Now it's simply a matter of passing this function down to <SearchBar /> from <App /> (as a prop, like an attribute)

    <SearchBar term={terms[0]} addTerm={addTerm} />

And then going into the submitted function in <SearchBar /> and haveing it use this function there to change the state in <App />

    export default function SearchBar(props) {
        function submitted(ev) {
            ev.preventDefault();
            console.log("submitted");
            props.addTerm(ev.target["keyword"].value);
    }

Notice this is similar ot what we did before when state was defined inside the <SearchBar /> component --> setTerm(ev.target["keyword"].value). Now, we are simply using a function from props to call a setter function living in another (higher/parent) Component.

This is possible because in JavaScript functions are objects and can be passed around, used as arguments, used as varibles, just like anything else.

Understanding that we want to keep state in a high function and pass it and a function that can use its setter down to child components as props is key to understanding the useState() Hook.

